# JDBC for Vert.x

A Vert.x library for interacting with a database that supports JDBC/SQL.

## Operations

The following operations are supported by this JDBC library.

### Execute

Executes the given sql on the database, returning nothing.

```java
String sql = "CREATE TABLE people (ID int generated by default as identity (start with 1 increment by 1) not null, FNAME varchar(255), LNAME varchar(255), DOB date);"
service.execute(sql, ar -> {
  if (ar.succeeded()) {
    System.out.println("Table created !");
  } else {
    ar.cause().printStackTrace();
  }
});
```

### Update

Updates the database `INSERT`, `UPDATE`, `DELETE`, passing the sql and parameters (optional). The result is a JsonObject
telling you how many rows were updated and the generated keys (if any) if it was an insert.

```java

service.update("INSERT INTO people VALUES (null, 'john', 'doe', '2000-01-01');", null, insertResult -> {
  if (insertResult.succeeded()) {
    JsonObject result = insertResult.result();
    System.out.println("Updated: " + insert.getInteger("updated");
    System.out.println("Generated keys: " + insert.getJsonArray("keys"));
  } else {
    insertResult.cause().printStackTrace();
  }
});

Update Result:

```javascript
{
  "updated" : 1     // number of rows effected by the update
  "keys"    : [1]   // array of generated keys
}
```


### Query

Queries the database (`SELECT`), passing the sql and parameters (optional). The result is a List of JsonObject's
representing the ResultSet of the query.

```java
JsonArray params = new JsonArray().add("doe");
service.query("SELECT * FROM people WHERE lname = ?", params, queryResult -> {
  if (queryResult.succeeded()) {
    System.out.println(queryResult.result());
  } else {
    queryResult.cause().printStackTrace();
  }
});
```

## Transactions

Each operation above has a corresponding transaction operation/method that accepts a transaction id. So to query within
a transaction you would call `queryTx`, and to update within a transaction you would call `updateTx`, etc.

To start a transaction, you can either pass in your own unique identifier or you can ask the service by calling `startTx`.

```java
service.startTx(startTxResult -> {
if (startTxResult.succeeded()) {
  String txId = startTxResult.result();
  // Now you can do a bunch of things within a transaction
  service.insertTx(txId, ...);
  // etc
} else {
  startTxResult.cause().printStackTrace();
}
});
```

### Commit

To commit a transaction, call `commit` using the transaction id.

```java
service.commit(txId, commitResult -> {
  System.out.println("Commit succeeded ? " + commitResult.succeeded());
});
```

### Commit

To rollback a transaction, call `rollback` using the transaction id.

```java
service.rollback(txId, rollbackResult -> {
  System.out.println("Rollback succeeded ? " + rollbackResult.succeeded());
});
```